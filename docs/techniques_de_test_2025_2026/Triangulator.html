<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>techniques_de_test_2025_2026.Triangulator API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>techniques_de_test_2025_2026.Triangulator</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="techniques_de_test_2025_2026.Triangulator.Triangulator"><code class="flex name class">
<span>class <span class="ident">Triangulator</span></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Triangulator:
    def __init__(self):
        self.manager_url = &#34;http://localhost:3000&#34;

    def triangulate(self, pointSetId):
        &#34;&#34;&#34;Orchestrateur (Service Layer)&#34;&#34;&#34;
        try:
            pset = self.get_point_set(pointSetId)
            result = self.compute(pset)
            return result.to_bytes()
        except Exception as e:
            raise e

    def get_point_set(self, pointSetId):
        # Basic UUID validation (length and hex) - simplified
        if len(pointSetId) != 36:
             raise Exception(&#34;incorrect uuid format&#34;)
        
        url = f&#34;{self.manager_url}/pointset/{pointSetId}&#34;
        try:
            with urllib.request.urlopen(url) as response:
                data = response.read()
                return PointSet.from_bytes(data)
        except urllib.error.HTTPError as e:
            if e.code == 404:
                raise Exception(&#34;Point set not found&#34;)
            elif e.code == 503:
                raise Exception(&#34;point set manager unavailable&#34;)
            else:
                raise Exception(f&#34;HTTP Error {e.code}&#34;)
        except urllib.error.URLError:
            raise Exception(&#34;point set manager unavailable&#34;)
        except Exception as e:
            raise e

    def compute(self, pset: PointSet) -&gt; Triangles:
        &#34;&#34;&#34;Algorithme de triangulation de Bowyer-Watson.
        Prend un PointSet en entrée et retourne un objet Triangles.
        &#34;&#34;&#34;
        # Tri des points par ordre croissant de x =&gt; permet de gagner du temps dans le parcours des points (pas besoin de parcourir tous les triangles pour chaque point)
        points = sorted(pset.points, key=lambda p: p.x)
        
        n = len(points)
        if n &lt; 3:
            return Triangles(points, [])
        
        self._check_collinearity(points)
        
        all_points, active_triangles = self._create_super_triangle(points)
        final_triangles = []
        
        for i, point in enumerate(points):
            bad_triangles, new_active_triangles, finished_triangles = self._find_bad_triangles(point, active_triangles)
            
            # Les triangles &#34;finis&#34; ne seront plus jamais affectés, on les stocke
            final_triangles.extend(finished_triangles)
            active_triangles = new_active_triangles
            
            polygon = self._find_hole_boundary(bad_triangles)
            
            self._fill_hole(polygon, i, all_points, active_triangles)
        
        # Ajoute les triangles restants a final
        for item in active_triangles:
             final_triangles.append(item[0])
                
        # Supprime les triangles connectés au super-triangle
        result_triangles = []
        for t in final_triangles:
            if t.a &lt; n and t.b &lt; n and t.c &lt; n:
                result_triangles.append(t)
                
        return Triangles(points, result_triangles)

    def _check_collinearity(self, points):
        # Super-triangle
        min_x = points[0].x
        max_x = points[-1].x
        min_y = min(p.y for p in points)
        max_y = max(p.y for p in points)
        
        is_collinear = True
        p0 = points[0]
        p_end = points[-1]
        
        # c&#39;est trié donc point 0 est le plus a gauche et point -1 est le plus a droite
        for p in points[1:-1]:
            if self.triangle_area(p0, p_end, p) &gt; 1e-9:
                is_collinear = False
                break
        
        # si les extremités sont les memes points alors on a une droite car tout les points sont tres proches 
        if abs(max_x - min_x) &lt; 1e-9 and abs(max_y - min_y) &lt; 1e-9:
             is_collinear = True
             pass
        elif is_collinear:
             raise ValueError(&#34;Collinear points&#34;)

    def _create_super_triangle(self, points):
        min_x = points[0].x
        max_x = points[-1].x
        min_y = min(p.y for p in points)
        max_y = max(p.y for p in points)

        dx = max_x - min_x
        # On definit le rectangle qui englobe tous les points
        dy = max_y - min_y
        delta_max = max(dx, dy)
        mid_x = (min_x + max_x) / 2
        mid_y = (min_y + max_y) / 2
        
        # points du super triangle =&gt; 20 = augmentation superficielle pour assurer que le super triangle englobe tous les points
        st_p1 = Point(mid_x - 20 * delta_max, mid_y - delta_max)
        st_p2 = Point(mid_x + 20 * delta_max, mid_y - delta_max)
        st_p3 = Point(mid_x, mid_y + 20 * delta_max)
        
        # Ajout des points du super triangle a la liste des points
        all_points = points + [st_p1, st_p2, st_p3]
        
        # calcul du triangle super et de son cercle circonscrit
        n = len(points)
        t0 = Triangle(n, n+1, n+2)
        c0, r0_sq = self.get_circumcircle(st_p1, st_p2, st_p3)
        
        # liste des triangles actifs (triangle, centre_x, centre_y, rayon au carré)
        active_triangles = [(t0, c0[0], c0[1], r0_sq)]
        
        return all_points, active_triangles

    def _find_bad_triangles(self, point, active_triangles):
        bad_triangles = []
        new_active_triangles = []
        finished_triangles = []
        
        px, py = point.x, point.y
        
        for item in active_triangles:
            t, cx, cy, r_sq = item
            
            dx_dist = px - cx
            # Si le carré de la distance sur x est supérieur au rayon au carré
            # ET que le point est à droite du centre (dx_dist &gt; 0),
            # alors on est sûr qu&#39;aucun point futur ne tombera dans ce cercle.
            if dx_dist &gt; 0 and (dx_dist**2) &gt; r_sq:
                finished_triangles.append(t)
                continue
            
            # Si le point est dans le cercle, ce triangle sera &#39;mauvais&#39;
            dist_sq = (cx - px)**2 + (cy - py)**2
            if dist_sq &lt; r_sq:
                bad_triangles.append(t)
            else:
                new_active_triangles.append(item)
                
        return bad_triangles, new_active_triangles, finished_triangles

    def _find_hole_boundary(self, bad_triangles):
        # polygon = frontiére du polygone formé par bad_triangles
        # Trouve la frontière du polygone formé par bad_triangles
        # Utilise un dictionnaire pour compter les arêtes: (min, max) -&gt; count
        edge_counts = {}
        for t in bad_triangles:
            for edge in [(t.a, t.b), (t.b, t.c), (t.c, t.a)]:
                sorted_edge = tuple(sorted(edge))
                # On compte le nombre d&#39;occurences de chaque arete (arrete comptée 2 fois si elle est partagée par 2 triangles / arrete comptée 1 fois si elle est frontière)
                edge_counts[sorted_edge] = edge_counts.get(sorted_edge, 0) + 1
        
        polygon = [edge for edge, count in edge_counts.items() if count == 1]
        return polygon

    def _fill_hole(self, polygon, point_index, all_points, active_triangles):
        # Re-triangule le trou
        for edge in polygon:
            new_t = Triangle(edge[0], edge[1], point_index)
            p1 = all_points[new_t.a]
            p2 = all_points[new_t.b]
            p3 = all_points[new_t.c]
            
            try:
                center, r_sq = self.get_circumcircle(p1, p2, p3)
                active_triangles.append((new_t, center[0], center[1], r_sq))
            except ValueError:
                 continue

    def get_circumcircle(self, p1: Point, p2: Point, p3: Point):
        &#34;&#34;&#34;Returns ((center_x, center_y), radius_sq)&#34;&#34;&#34;
        # https://en.wikipedia.org/wiki/Circumcircle pour la formule
        ax, ay = p1.x, p1.y
        bx, by = p2.x, p2.y
        cx, cy = p3.x, p3.y
        
        # determinant = 2 fois l&#39;aire du triangle
        D = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by))
        if abs(D) &lt; 1e-12:
            raise ValueError(&#34;Collinear points&#34;)

        # Coord du centre  
        ux = ((ax**2 + ay**2) * (by - cy) + (bx**2 + by**2) * (cy - ay) + (cx**2 + cy**2) * (ay - by)) / D
        uy = ((ax**2 + ay**2) * (cx - bx) + (bx**2 + by**2) * (ax - cx) + (cx**2 + cy**2) * (bx - ax)) / D
        
        # Rayon au carré : distance entre le centre et un des points
        r_sq = (ux - ax)**2 + (uy - ay)**2
        return (ux, uy), r_sq

    def triangle_area(self, p1, p2, p3):
        return 0.5 * abs(p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y))</code></pre>
</details>
<div class="desc"></div>
<h3>Methods</h3>
<dl>
<dt id="techniques_de_test_2025_2026.Triangulator.Triangulator.compute"><code class="name flex">
<span>def <span class="ident">compute</span></span>(<span>self, pset: models.PointSet.PointSet) ‑> models.Triangles.Triangles</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute(self, pset: PointSet) -&gt; Triangles:
    &#34;&#34;&#34;Algorithme de triangulation de Bowyer-Watson.
    Prend un PointSet en entrée et retourne un objet Triangles.
    &#34;&#34;&#34;
    # Tri des points par ordre croissant de x =&gt; permet de gagner du temps dans le parcours des points (pas besoin de parcourir tous les triangles pour chaque point)
    points = sorted(pset.points, key=lambda p: p.x)
    
    n = len(points)
    if n &lt; 3:
        return Triangles(points, [])
    
    self._check_collinearity(points)
    
    all_points, active_triangles = self._create_super_triangle(points)
    final_triangles = []
    
    for i, point in enumerate(points):
        bad_triangles, new_active_triangles, finished_triangles = self._find_bad_triangles(point, active_triangles)
        
        # Les triangles &#34;finis&#34; ne seront plus jamais affectés, on les stocke
        final_triangles.extend(finished_triangles)
        active_triangles = new_active_triangles
        
        polygon = self._find_hole_boundary(bad_triangles)
        
        self._fill_hole(polygon, i, all_points, active_triangles)
    
    # Ajoute les triangles restants a final
    for item in active_triangles:
         final_triangles.append(item[0])
            
    # Supprime les triangles connectés au super-triangle
    result_triangles = []
    for t in final_triangles:
        if t.a &lt; n and t.b &lt; n and t.c &lt; n:
            result_triangles.append(t)
            
    return Triangles(points, result_triangles)</code></pre>
</details>
<div class="desc"><p>Algorithme de triangulation de Bowyer-Watson.
Prend un PointSet en entrée et retourne un objet Triangles.</p></div>
</dd>
<dt id="techniques_de_test_2025_2026.Triangulator.Triangulator.get_circumcircle"><code class="name flex">
<span>def <span class="ident">get_circumcircle</span></span>(<span>self, p1: models.Point.Point, p2: models.Point.Point, p3: models.Point.Point)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_circumcircle(self, p1: Point, p2: Point, p3: Point):
    &#34;&#34;&#34;Returns ((center_x, center_y), radius_sq)&#34;&#34;&#34;
    # https://en.wikipedia.org/wiki/Circumcircle pour la formule
    ax, ay = p1.x, p1.y
    bx, by = p2.x, p2.y
    cx, cy = p3.x, p3.y
    
    # determinant = 2 fois l&#39;aire du triangle
    D = 2 * (ax * (by - cy) + bx * (cy - ay) + cx * (ay - by))
    if abs(D) &lt; 1e-12:
        raise ValueError(&#34;Collinear points&#34;)

    # Coord du centre  
    ux = ((ax**2 + ay**2) * (by - cy) + (bx**2 + by**2) * (cy - ay) + (cx**2 + cy**2) * (ay - by)) / D
    uy = ((ax**2 + ay**2) * (cx - bx) + (bx**2 + by**2) * (ax - cx) + (cx**2 + cy**2) * (bx - ax)) / D
    
    # Rayon au carré : distance entre le centre et un des points
    r_sq = (ux - ax)**2 + (uy - ay)**2
    return (ux, uy), r_sq</code></pre>
</details>
<div class="desc"><p>Returns ((center_x, center_y), radius_sq)</p></div>
</dd>
<dt id="techniques_de_test_2025_2026.Triangulator.Triangulator.get_point_set"><code class="name flex">
<span>def <span class="ident">get_point_set</span></span>(<span>self, pointSetId)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_point_set(self, pointSetId):
    # Basic UUID validation (length and hex) - simplified
    if len(pointSetId) != 36:
         raise Exception(&#34;incorrect uuid format&#34;)
    
    url = f&#34;{self.manager_url}/pointset/{pointSetId}&#34;
    try:
        with urllib.request.urlopen(url) as response:
            data = response.read()
            return PointSet.from_bytes(data)
    except urllib.error.HTTPError as e:
        if e.code == 404:
            raise Exception(&#34;Point set not found&#34;)
        elif e.code == 503:
            raise Exception(&#34;point set manager unavailable&#34;)
        else:
            raise Exception(f&#34;HTTP Error {e.code}&#34;)
    except urllib.error.URLError:
        raise Exception(&#34;point set manager unavailable&#34;)
    except Exception as e:
        raise e</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="techniques_de_test_2025_2026.Triangulator.Triangulator.triangle_area"><code class="name flex">
<span>def <span class="ident">triangle_area</span></span>(<span>self, p1, p2, p3)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def triangle_area(self, p1, p2, p3):
    return 0.5 * abs(p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y))</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="techniques_de_test_2025_2026.Triangulator.Triangulator.triangulate"><code class="name flex">
<span>def <span class="ident">triangulate</span></span>(<span>self, pointSetId)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def triangulate(self, pointSetId):
    &#34;&#34;&#34;Orchestrateur (Service Layer)&#34;&#34;&#34;
    try:
        pset = self.get_point_set(pointSetId)
        result = self.compute(pset)
        return result.to_bytes()
    except Exception as e:
        raise e</code></pre>
</details>
<div class="desc"><p>Orchestrateur (Service Layer)</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="techniques_de_test_2025_2026" href="index.html">techniques_de_test_2025_2026</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="techniques_de_test_2025_2026.Triangulator.Triangulator" href="#techniques_de_test_2025_2026.Triangulator.Triangulator">Triangulator</a></code></h4>
<ul class="">
<li><code><a title="techniques_de_test_2025_2026.Triangulator.Triangulator.compute" href="#techniques_de_test_2025_2026.Triangulator.Triangulator.compute">compute</a></code></li>
<li><code><a title="techniques_de_test_2025_2026.Triangulator.Triangulator.get_circumcircle" href="#techniques_de_test_2025_2026.Triangulator.Triangulator.get_circumcircle">get_circumcircle</a></code></li>
<li><code><a title="techniques_de_test_2025_2026.Triangulator.Triangulator.get_point_set" href="#techniques_de_test_2025_2026.Triangulator.Triangulator.get_point_set">get_point_set</a></code></li>
<li><code><a title="techniques_de_test_2025_2026.Triangulator.Triangulator.triangle_area" href="#techniques_de_test_2025_2026.Triangulator.Triangulator.triangle_area">triangle_area</a></code></li>
<li><code><a title="techniques_de_test_2025_2026.Triangulator.Triangulator.triangulate" href="#techniques_de_test_2025_2026.Triangulator.Triangulator.triangulate">triangulate</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
